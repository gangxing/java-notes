> 事务 锁 索引 日志文件 数据文件 各种buffer flush等概念的串起来 
>
> 能够解释常见场景下 单个事务和多事务并发场景下，MySQL内部处理机制

在MySQL中，按照锁定的范围，可以分为全局锁、表级锁、行级锁。

**全局锁**

对MySQL进程中的某个库上锁，上锁的命令`FLUSH TABLES WITH READ LOCK;`,这是当前数据库处于只读状态，所有会改变数据、表结构等写操作都会被阻塞。试验在只读状态下执行insert操作，返回’Can't execute the query because you have a conflicting read lock‘。（为什么是读锁冲突？）

全局锁的使用场景是备份库,解锁操作`UNLOCK TABLES;`

当然备份过程中，肯定是要保证数据不会变更的，不然会导致，课程中说的加入一个购买流程，包括添加课程和扣款两个操作，如果不加全局锁，在备份的时候就可能出现只会读到其中一个操作的数据，这就导致了数据错乱？

你可能会问，这两个操作不应该是在同一个事务中的吗，如果只执行了一个动作，说明事务还未提交，你肯定还看不到更新呀。这个逻辑我觉得有一定的道理，但假如这是由两个服务操作的，也就是分布式事务的场景下，当前表的操作肯定先提交了。所以就能读到了。

在备份数据时使用全局锁，不能再写入了，那服务就得停摆，并且作为从库时，也不能及时同步主库过来的binlog了。所以这种方式的成本很高。基于这个原因，我们可以选用另一种方案，将dump操作放在一个可重复读的事务中，利用innodb的mvvc机制，就保证了不会读到中间状态的数据了。

