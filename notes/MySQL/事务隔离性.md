现在常规的应用系统中，每一个接口基本都需要执行多条更新SQL。这就要求多条SQL的更新要么全部生效，要么全部都不生效。这就是所谓的原子性，事务的四大特性之一。MySQL原生的存储引MyISAM是不支持事务的，因此大部分场景都需要用InnoDB存储引擎，其也是新版MySQL的默认存储引擎。

> 事务之ACID特性
>
> Atomicity-原子性
>
> Consistency-一致性
>
> Isolation-隔离性
>
> Durability-持久性

隔离级别是为了解决多个事务同时执行过程中，会出现的脏读，不可重复读和幻读问题

> ###### 脏读-Dirty Read
>
> 读到了其他事务未提交的更新，当那个事务回滚后，这条更新就是脏数据了。
>
> ###### 不可重复读-Nonrepeatable Read
>
> 针对同一条数据，第一次读的时候还未提交，第二次再读的时候，已经提交了，所以读到了。
>
> ###### 幻读-Phantom Read
>
> 针对范围查询，第二次再读的时候，其他事务提交了一条更新，在这个范围内。对当前事务来说，
>
> 第二次读的时候，比第一次读的时候多了一条数据。
>
> 

针对上面每种问题，数据库规范？定义了四种隔离级别

> READ_UNCOMMITED
>
> 当前事务可以看到其他事务未提交的更新
>
> READ_COMMITED
>
> 当前事务只能读到其他事务已提交的更新
>
> REPEATABLE_READ
>
> 当前事务中任何时刻读取的数据都一致，即使其他事务的更新已经提交了
>
> SERIALIABLE
>
> 事务串行



各种隔离级别的实现方案，事务访问的数据都是以视图的逻辑结果为准。在REPEATABLE_READ隔离 级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在READ_COMMITED隔离级 别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，READ_UNCOMMITED隔离级别下直接返回记录上的最新值，没有视图概念;而SERIALIABLE隔离级别下直接用加锁的方式来避 免并行访问。

综上，为解决多事务并发问题，针对不同问题采用不同的解决方案

> 1.MVVC-Multi Version Currency Control,利用undo log实现的视图逻辑结果，具体实现方案见[https://www.jianshu.com/p/f692d4f8a53e
>
> 2.加锁，使事务串行执行

> 问题：在具体实现中，两种方案是怎么配合使用的？







