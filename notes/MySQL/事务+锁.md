> MySQL利用MVVC(MVVC又是依据undo log实现的)，在一个可重复读的事务执行过程中，读取到的数据都是事务开始时获取的快照，实现了事务见的隔离。
>
> 而在锁部分，MySQL更新一条数据会获取当前行的写锁，防止其他事务对当前行的并发更新。
>
> 问题：如果获取到锁后，当前事务看到的结果是更新后的还是更新前的？？？



结合下面案例，详细了解之

背景：REPEATABLE_READ， autocommit=1

表的定义如下

```sql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);
```

​	![mysql-learn.png](https://i.loli.net/2019/10/28/FXudZ2UVWSHbxnc.png)

问题：事务A和事务B分别读到的k是多少；结果是事务A读到的是1；事务B读到的是3。

对于事务A，按照

关于事务启动的时机

`begin`或者`start transaction `后面第一条SQL执行时才会开启事务

`start transacton with consistent snapshot`会立即开启事务



```mysql
set session transaction read only;//只读事务
set session transaction read write;//读写事务
```

MVVC详细机制



更新数据都是“先读后写”，读到的都是最新的值，称之为“当前读”。













> SERIALIABLE 隔离级别下的select 和 select lock in share mode 有何异同
>
> 