> MySQL利用MVCC(MVCC又是依据undo log实现的)，在一个可重复读的事务执行过程中，读取到的数据都是事务开始时获取的快照，实现了事务见的隔离。
>
> 而在锁部分，MySQL更新一条数据会获取当前行的写锁，防止其他事务对当前行的并发更新。
>
> 问题：如果获取到锁后，当前事务看到的结果是更新后的还是更新前的？？？



结合下面案例，详细了解之

背景：REPEATABLE_READ， autocommit=1

表的定义如下

```sql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);
```



| 事务A                                       | 事务B                                                        | 事务 C                         |
| ------------------------------------------- | ------------------------------------------------------------ | ------------------------------ |
| start transaction with consistent snapshot; |                                                              |                                |
|                                             | start transaction with consistent snapshot;                  | update t set k=k+1 where id=1; |
|                                             | update t set k=k+1 where id=1; <br/>select k from t where id=1; |                                |
| select k from t where id=1; <br/>commit;    |                                                              |                                |
|                                             | commit;                                                      |                                |



在上面的流程中，事务A读到的是1；事务B读到的是3。根据MVCC，可重复读隔离级别下，事务A中读到的k是1，可以理解，同理，事务B中在更新时读到的也是1，更新后，再次读到应该是2才对呀。基于这个问题，再深入了解MVCC机制到底是怎么运作的。

在MySQL中，有两个“视图”的概念：

* 一个是view,用于查询时定义的虚拟表，创建视图的语法是`create view;`视图的查询方法与表的查询方法一致。

* 另一个是InnoDB实现MVCC用到的一致性读视图，即consistent read view,用于实现在READ_COMMITED和REPEATABLE_READ隔离级别下，每次读到的都是指定的“快照”。

InnoDB中，每个事务都有一个唯一的事务ID,叫transaction id,在事务开始的时候向InnoDB的事务系统申请的，严格递增。关于事务启动的时机：

> A autocommit=1
>
> 1. 没有明确指定事务的开启，每一条SQL都有一个属于自己的完整的事务，即执行SQL的时候就启动了事务
>
> 2. 明确指定了事务的开始，有以下两种情况
>
> * `begin` 或者 `start transaction` 后面第一条SQL执行时才会开启事务
>
> * `start transacton with consistent snapshot` 会立即开启事务
>
> B autocommit=0
>
> 在连接建立后，就开启一个事务，直到执行了commit或者rollback，当前事务结束并自动开启一个新事务。

有了transaction id，事务更新数据的时候将当前事务的transaction id赋值给这个数据的版本的事务ID,记为row trx_id，记录这个数据的更新是由哪个事务产生的。并在undo log中记录同时，旧的版本数据要保留。（至于要保留多久，会不会清理，什么时候清理，后面再谈）//TODO 所以在可重复读的隔离级别下，每次读都只会读到事务启动时看到的数据，尽管中间可能有其他事务更新了数据并且提交了。这是因为通过

在实现上，InnoDB为每个事务构造了一个数组，保存此事务启动时刻所有活跃的事务ID。数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位。 如下图所示

![事务水位.png](https://i.loli.net/2019/10/28/TfpxcMmHOruX1z2.png)



这样，对于当前事务启动的瞬间来说，一个数据版本的row trx_id有以下几种可能:

1. 落在绿色区域，表示这个版本是已经提交的或<font color="#dd0000">当前事务自己</font>生成的，对当前事务可见；

2. 如果落在红色区域，表示这个版本是由将来启动的事务生成的，对当前事务不可见；

3. 如果落在黄色区域，有两种场景：

   * row trx_id在数组中，表示这个版本是由还未提交的事务生成的，对当前事务不可见；

   * row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，对当前事务可见。

<font color="#0000CD">对上面几点结论不是很理解。。。</font>

https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/

https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html

https://blog.csdn.net/shaochenshuo/article/details/72677324

淘宝就是给力呀，但这都是内核级的，关于性能优化等方案探讨 不算是概念性解释

http://mysql.taobao.org/monthly



按照我自己的理解，在当前事务开始的时候，

每行数据除了业务字段，还有三个隐藏的字段 row_id, DB_TRX_ID,DB_ROLL_PTR

问题，读到的都是最新的数据，待row_trx_id。怎么判断这个版本是否提交了，换句话说，怎么知道知道row_trx_id这个事务已经提交了与否？？？最直接的方式就看源码，但是成本太高了。。。。

先看官方文档，尝试了解MVCC的实现。官方文档也只是简单概念，并没有介绍其实现。

了解“快照”概念，在REPEATABLE_READ隔离级别下，在事务开始的时候构造一次“快照”，

在READ_COMMITED隔离级别下，每次statement都构造一次“快照”？





在更新SQL执行中，也会先读后写，这里的读是MySQL内部执行的逻辑，跟select读是两回事，写之前的读叫“当前读”，读的是最新值。如果不读最新的值，那就相当于忽略了其他事务的更新，就有可能会脏读。



不管什么配置前提下，每条SQL都是在某一个事务中执行的，对于更新类SQL（insert update delete等）是要获取锁的，如果有有其他事务正持有这个锁，当前事务被阻塞。对于读类的SQL（select），默认是不加锁的，根据一般的隔离级别（REPEATABLE_READ）,可能是导致读取的不是“最新的数据”，select也是支持加锁的，`select for update`获取的是X锁，`select xxx lock in share mode`获取的是S锁。

再看“当前读”，我的理解为了读取到最新的数据，应该是要加锁。





再看事务





**只读事务**

怎么指定只读事务，本质是什么，只读事务和不开启事务有何区别？

```mysql
set session transaction read only;//只读事务
set session transaction read write;//读写事务
```

在只读事务中，如果执行更新类SQL，会返回'Cannot execute statement in a READ ONLY transaction.'这是理所当然的，不然还叫什么只读事务。只读事务的存在意义是什么，仅仅只是为了防止在事务中有更新操作？？？？









***锁和事务的产生背景***

MySQL采用的是One Thread per Connection(新版MySQL已支持线程池)，这就产生了资源并发访问的问题，直接的解决方案就是加锁，将同一个资源的访问的访问串行化。根据实际使用经验，很多应用都是读多写少的场景，所以读和读互斥显得不是很必要。所以就将锁细化，分成读写锁，这样就避免了读和读之间的互斥，很大地提高了系统的并发能力。当然，读写、写写还是要互斥的。即便是支持并发读读了，那能不能进一步支持读写并发，即不管其他线程怎么修改，不影响当前线程的读。这就有了MVCC。



> SERIALIABLE 隔离级别下的select 和 select lock in share mode 有何异同
>
> 