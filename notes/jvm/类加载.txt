一、什么是类加载
将class文件中的二进制数据读入内存，将其放在运行时数据区域的方法区，然后在堆中创建一个java.lang.Class对象，
这是类加载后的最终产品，Class对象封装了类在方法区内的数据结构，并提供了访问方法区内的数据结构的接口

二、类的生命周期（类的加载过程）
加载、验证、准备、解析、初始化、使用、卸载
TODO 详细讲讲每个阶段需要做的事情 暂时不表

类的加载方式
1.命令行启动应用时候由JVM初始化加载
2.通过Class.forName()方法动态加载
3.通过ClassLoader.loadClass()方法动态加载

三、类加载器
从上往下
1.启动类加载器 Bootstrap Classloader

2.扩展类加载器 Extension Classloader

3.应用类加载器 Application Classloader

4.自定义类加载器 User Classloader

ps:这里的父类加载器不是通过继承实现的 而是通过组合实现的

从虚拟机角度来讲只有两种类加载器
1.启动类加载器 用C++实现 属于虚拟机的一部分
2.其他的类加载器 用Java实现 独立于虚拟机 并且全部继承于抽奖类java.lang.ClassLoader

站在开发人员角度来讲 类加载器大致可以分为以下三类
1.启动类加载器 负责JDK/jre/lib, -Xbootclasspath参数指定的路径中，并且能被虚拟机识别的类库 （以java.*开头的类）
2.扩展类加载器 负责JDK/jre/lib/ext目录中 ,java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类)
    开发者可以直接使用扩展类加载器
3.应用程序类加载器 负责加载用户类路径classpath所指定的类 一般情况下应用程序类加载器就是程序中默认的类加载器

什么场景会使用自定义class loader
1.为了安全，防止类反编译，可以先将class文件加密 然后自定义类加载器先解密再加载 因为加密过的class文件不能被
上面几种类加载器正常加载
2.从非标准的来源加载 比如字节码通过网络得到、数据库等

自己实现类加载器
继承ClassLoader 重写findClass方法
自定义类加载器的核心在于对字节码文件的获取

双亲委派模型
当类加载器遇到加载需求时，先从自己已加载的类中查询是否已加载 如果没加载 委托给父类加载器 直至启动类加载器
因为每一种加载器都有自己负责的范围 当在自己所负责的范围内加载失败（没找到该class文件）抛出异常，下一级类加载器
捕获异常 尝试自己加载 直至到达最后的应用类加载器 如果此时还是加载失败 则会抛出ClassNotFoundException异常
双亲委派模型的目的

为了安全 避免用户加载jdk核心类库
同时为了避免重复加载类 因为在虚拟机层面 类的唯一性判定标准是类的全限定名称+类加载器




