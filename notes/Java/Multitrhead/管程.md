管程-Monitor

一种通用的同步原语，在Java中指的是synchronized,即synchronized是Java里对管程的实现。

> 参考：
>
> https://www.cnblogs.com/paddix/p/5405678.html
>
> https://blog.csdn.net/zqz_zqz/article/details/70233767

`synchronized`是依赖monitorenter和monitorexit两个指令完成的。线程获取不到锁的时候会被阻塞，阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源。所以说`synchronized`是一个重量级锁。

另一方面，在并发度不高的情况下，甚至大部分时间只有一个线程执行，这时候都要执行加锁和解锁操作，实属无意义。

基于上面两个原因，对锁进行了优化，从JDK1.5开始，引入了轻量级锁和偏向锁，默认启用了自旋锁。（这三种锁都属于乐观锁）

**锁的实现原理**

Java对象结构分为3部分：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。其中对象头分为两部分：**markword**和**kclass**。markword用于存储对象运行时数据，比如hashCode,GC分代年龄，锁状态标识，线程持有的锁，偏向线程ID，偏向时间戳等。markword数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，**最后2bit是锁状态标志位**。



![32位markword结构图](https://i.loli.net/2019/11/28/4IhpkiHYORxoBNe.png)



> 问题，在无锁的时候，markword中存储了hashCode,分代年龄，当被锁住的时候，这些数据存到哪里的？
>
> https://mp.weixin.qq.com/s/O8SIoyICc5NmZOBbjlCXhg



* 重量级锁

  学习学习

* 轻量级锁

  学习学习

* 偏向锁（Biased Locking）

  偏向于第一个获取锁的线程，如果只有当前一个线程获取锁，则不需要同步。如果在运行过程中，其他线程也要获取锁，则持有偏向锁的线程会被挂起，JVM消除偏向锁，将锁恢复到轻量级锁。

  *适用场景*

  适用于无竞争的场景。

  开启偏向锁：`-XX:+UseBiasedLocking`

  关闭偏向锁：`-XX:-UseBiasedLocking`

* 自旋锁

  学习学习









JVM对各种锁的选择

以上各种锁是JVM内部对`synchronized`针对不同场景的优化而提出的概念和实现。在编码中，统一都是使用`synchronized`。

> 类似于`Arrays.sort(int[] arr)`,JDK从源数据的数据量大小、有序度等维度选择不同的排序算法来实现，对上层使用透明。

JVM实现`synchronized`的逻辑，

1. 检测markword里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁
2. 如果不是，则使用CAS将当前线程的ID替换markword，如果成功则表示当前线程获得偏向锁，置偏向标志位1
3. 如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。
4. 当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁
5. 如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
6. 如果自旋成功则依然处于轻量级状态。
7. 如果自旋失败，则升级为重量级锁。

总结：JVM尝试从偏向锁、轻量级锁、自旋锁到重量级锁顺序来选择不同的锁来实现`synchronized`。





**锁优化**

`synchronized`是由JVM实现的，不受上层代码控制，但是参照`synchronized`的优化思想，对`synchronized`的使用也是可以优化的。

*减少锁的持有时间*



*细化锁的粒度*

用不同的锁同步不同的资源，降低锁竞争，从而增大并发度。(用空间换时间的思路)使用举例

* `ConcurrentHashMap`对每一个数组元素加锁，而不是对整个数组加锁

* `LongAdder`,计数的实现，当并发度高时，每个线程分别计数，获取总数时累加

* `LinkedBlockingQueue`,因为入队只会操作队尾节点，出队只会操作队首节点。所以入队和出队使用的不同的锁

  

*锁粗化*

假如需要对循环内的操作加锁，这时需要将加锁操作放到循环体外。

*读写分离*

能实现读读并发，比如`CopyOnWriteArrayList`和`ReadWriteLock`

volatile+CAS*

当并发度不高时，加锁/释放锁会导致线程的上下文切换。

*消除CPU缓存行的伪共享*

简单解释，因为CPU缓存的存在，并且CPU读取数据的最小单位是缓存行(32位的cpu缓存行为32字节，64位cup的缓存行为64字节)，当不需要同步的变量和需要同步的变量存在同一个缓存行中，对不需要同步的变量的访问也需要同步操作了。将需要独占缓存行的变量前后加一组long类型变量。

