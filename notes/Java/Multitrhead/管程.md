管程-Monitor

一种通用的同步原语，在Java中指的是synchronized,即synchronized是Java里对管程的实现。

> 参考：
>
> https://www.cnblogs.com/paddix/p/5405678.html
>
> https://blog.csdn.net/zqz_zqz/article/details/70233767

`synchronized`是依赖monitorenter和monitorexit两个指令完成的。线程获取不到锁的时候会被阻塞，阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源。所以说`synchronized`是一个重量级锁。

另一方面，在并发度不高的情况下，甚至大部分时间只有一个线程执行，这时候都要执行加锁和解锁操作，实属无意义。

基于上面两个原因，对锁进行了优化，从JDK1.5开始，引入了轻量级锁和偏向锁，默认启用了自旋锁。（这三种锁都属于乐观锁）

**锁的实现原理**

Java对象结构分为3部分：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。其中对象头分为两部分：**markword**和**kclass**。markword用于存储对象运行时数据，比如hashCode,GC分代年龄，锁状态标识，线程持有的锁，偏向线程ID，偏向时间戳等。markword数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，**最后2bit是锁状态标志位**。



![32位markword结构图](https://i.loli.net/2019/11/28/4IhpkiHYORxoBNe.png)



> 问题，在无锁的时候，markword中存储了hashCode,分代年龄，当被锁住的时候，这些数据存到哪里的？
>
> https://mp.weixin.qq.com/s/O8SIoyICc5NmZOBbjlCXhg




* 偏向锁（Biased Locking）

  偏向于第一个获取锁的线程，如果只有当前一个线程获取锁，则不需要同步。如果在运行过程中，其他线程也要获取锁，则持有偏向锁的线程会被挂起，JVM消除偏向锁，将锁恢复到轻量级锁。

  *获取过程*

  1. 判断可偏向状态

  2. 如果是1，表示可偏向，判断线程ID是否为当前线程ID，如果是执行步骤5，如果不是执行步骤3

  3. 如果线程ID未指向当前线程，通过CAS将当前线程ID设置给线程ID，如果设置成功，执行步骤5，如果失败执行步骤4

  4. CAS获取偏向锁失败，表示有竞争，当达到全局安全点时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行临界区代码

     > 不是很懂。。。。

  5. 执行临界区代码

  *释放过程*

  偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁（线程不会主动释放偏向锁）。执行到安全点，线程被挂起，根据对象是否处于被锁定状态将标志位恢复到无锁状态(01)或者轻量级锁状态(00)。

  > 当线程B尝试获取偏向锁，发现偏向锁已被线程A持有，这时候线程A有两种状态1. 在执行临界区代码，2.  已执行完临界代码。两种状态的统一操作挂起线程A，关闭偏向锁标识。对于状态2，将锁标志位设为无锁状态(01),线程B（和其他线程还是尝试获取偏向锁）；对于状态1，将锁标志位设为轻量级锁(00),线程B需要获取到轻量级锁才能进入临界区，那此时线程A（已经在临界区了）呢？先看轻量级锁的获取过程再回来看

  *适用场景*

  适用于无竞争的场景。

  开启偏向锁：`-XX:+UseBiasedLocking`

  关闭偏向锁：`-XX:-UseBiasedLocking`

* 轻量级锁

  从获取偏向锁的流程中得知，当偏向锁已被其他线程持有的时候，偏向锁会升级为轻量级锁，当前线程再尝试获取轻量级锁，获取轻量级锁流程

  1. 如果同步对象为无锁状态(标志位01，偏向锁0)，JVM在当前线程的栈帧中建立一个名为锁记录(Lock Record)空间，存储同步对象当前markword数据，官方称之为Displaced Mark Word，lock record还持有同步对象的指针，叫owner。
  2. 将markword数据复制到lock record中
  3. 通过CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，成功后将Lock record里的owner设置为同步对象指针，如果更新成功，执行步骤4，如果更新失败执行步骤5。
  4. 将markword中的锁标识位设为00，表示此对象处于轻量级锁状态。并执行步骤6。
  5. 更新失败，JVM检查markword是否指向当前线程栈帧。如果是(说明重入)，执行步骤6，如果不是说明已被其他线程持有了轻量级锁，则轻量级锁要膨胀为重量级锁，锁标识位改为10，markword中存的是同步对象的指针（在同步对象的对象头中存该对象自己的指针？这个变更操作由哪个线程执行？）后面尝试获取锁的线程进入阻塞状态，当前线程便尝试使用自方式来获取锁(CAS更新markword为自己的lock record指针)，如果自旋一定次数后还是未能获取到到锁，则进入阻塞状态，获取到后执行步骤6。
  6. 执行临界区代码

  

  释放流程

  释放锁线程视角

  当持有轻量级锁线程离开临界区时，释放轻量级锁，在释放过程中，如果发现锁标识被改成了重量级锁（在持有轻量级锁期间有其他线程尝试获取锁），轻量级锁升级到重量级锁是发生在轻量级锁释放过程中，
  
  
  
  获取锁线程视角
  
  如果线程尝试获取锁的时候，发现是轻量锁并且被其他线程持有，则将锁标识修改为10（表示该锁为重量级锁），修改markword（为同步对象指针？）
  
  
  
  > 问题：线程A持有轻量级锁，线程尝试获取时，CAS更新markword已失败，进入自旋，那有没有改变什么？
  >
  > 线程A释放轻量级锁也会CAS把markword替换回去，如果前面线程B有修改，线程A才有有失败的情况，如果线程B有修改，修改了什么，都已经CAS失败了。
  
  
  
  
  
* 自旋锁

  执行空循环，防止自己进入阻塞状态。如果自旋一定次数后，依旧未获取到锁，则进入阻塞状态。

  选择自旋的假设前提是锁会被很快释放，但会占据CPU，如果自旋次数过多，CPU浪费，甚至自旋次数达到最大限制后，依旧会进入阻塞状态，比起直接进入阻塞状态，强占CPU这段时间更是浪费。另外，还需满足一个条件：多核，如果只有一个CPU，当前线程占有CPU，那持有轻量级锁的线程也不会被执行，也就没有释放锁一说了。

  在JDK6中，通过`-XX:+UseSpinning`开启自旋锁，并通过`-XX:PreBlockSpin=10`指定自旋次数。在JDK7中，去掉了这个配置，JVM自己掌控自旋次数，会动态调整自旋次数，叫自适应自旋，是对自旋锁的优化。

  

* 重量级锁

  在尝试获取锁时发现锁标识是重量级锁，则进入阻塞状态，待锁被释放时被唤醒，再次尝试获取锁。
  
  > 怎么确定重量级锁被哪个线程持有呢？或者说线程在释放重量级锁时操作了什么，怎么判断该锁是否被自己持有。



以上各种锁是JVM内部对`synchronized`针对不同场景的优化而提出的概念和实现。在编码中，统一都是使用`synchronized`。

> 类似于`Arrays.sort(int[] arr)`,JDK从源数据的数据量大小、有序度等维度选择不同的排序算法来实现，对上层使用透明。

JVM实现`synchronized`的逻辑，

1. 检测markword里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁
2. 如果不是，则使用CAS将当前线程ID替换markword，如果成功则表示当前线程获得偏向锁，置偏向标志位1
3. 如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。
4. 当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁
5. 如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
6. 如果自旋成功则依然处于轻量级状态。
7. 如果自旋失败，则升级为重量级锁。

总结：JVM尝试从偏向锁、轻量级锁、自旋锁到重量级锁顺序来选择不同的锁来实现`synchronized`。

![加锁过程](https://i.loli.net/2019/11/28/PEGp3fK6YM2yuQx.jpg)



**锁优化**

`synchronized`是由JVM实现的，不受上层代码控制，但是参照`synchronized`的优化思想，对`synchronized`的使用也是可以优化的。

*减少锁的持有时间*

尽可能将不需要同步的逻辑放到临界区外。

*细化锁的粒度*

用不同的锁同步不同的资源，降低锁竞争，从而增大并发度。(用空间换时间的思路)使用举例

* `ConcurrentHashMap`对每一个数组元素加锁，而不是对整个数组加锁

* `LongAdder`,计数的实现，当并发度高时，每个线程分别计数，获取总数时累加

* `LinkedBlockingQueue`,因为入队只会操作队尾节点，出队只会操作队首节点。所以入队和出队使用的不同的锁

  

*锁粗化*

假如需要对循环内的操作加锁，这时需要将加锁操作放到循环体外。

*读写分离*

能实现读读并发，比如`CopyOnWriteArrayList`和`ReadWriteLock`

*volatile+CAS*

当并发度不高时，加锁/释放锁会导致线程的上下文切换。

*消除CPU缓存行的伪共享*

简单解释，因为CPU缓存的存在，并且CPU读取数据的最小单位是缓存行(32位的cpu缓存行为32字节，64位cup的缓存行为64字节)，当不需要同步的变量和需要同步的变量存在同一个缓存行中，对不需要同步的变量的访问也被同步了。消除方案：将需要独占缓存行的变量前后加一组long类型变量。

