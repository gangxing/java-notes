

三个Java内置类加载器

**Bootstrap ClassLoader**

负责加载Java基础类，主要是$JRE_HOME​/lib目录下的rt.jar,resources.jar,charsets.jar，通过sun.boot.class.path配置确定

**Extension ClassLoader**

负责加载Java扩展类，主要是$JRE_HOME/lib/ext目录下的jar，通过java.ext.dirs配置确定

**App ClassLoader**

负责加载当前应用的ClassPath中的所有类，通过java.class.path配置确定

> 所谓classpath包括前面两个类加载器包含的jar包，应用依赖的所有jar包，应用所有的class所在的目录。



三个内置类加载器初始化流程

Bootstrap ClassLoader属于JVM的一部分，用C++实现，Extension ClassLoader和App ClassLoader是Java语言级的。JVM启动Bootstrap ClassLoader,然后初始化sum.misc.Launcher,Launcher初始化Extension ClassLoader和App ClassLoader。

为什么要多多个ClassLoader,各自管控的范围不同，那具体各个ClassLoader怎么分工协作的呢？这就有了类加载器的层级关系和双亲委派模型。加载器层级关系

AppClassLoader的父类加载器是ExtClassLoader,ExtClassLoader的父类加载器是Bootstrap ClassLoader。

> 由于Bootstrap ClassLoader是JVM部分，而不是Java语言级，所以ExtClassLoader在java语言层的父类加载器是null。

双亲委派模型，当某个类加载接到加载类的任务时(loadClass被调用)，先让父类加载器加载，迭代直至顶层类加载器Bootstrap ClassLoader,Bootstrap ClassLoader尝试在自己负责的范围找该class文件，如果没找到抛出ClassNotFoundException，让下层ClassLoader捕获，从下层ClassLoader视角来看，当上层ClassLoader抛出ClassNotFoundException后，捕获之，自己来加载(调用findClass),如果自己没找到也抛出ClassNotFoundException，迭代，直至最下层类加载器，如果最下层类加载器还是没找到该class文件，就真的抛出ClassNotFoundException了（再没有下级来捕获了）。

真正执行类加载的逻辑,见`ClassLoader.loadClass()`，核心逻辑如下

```java
protected Class<?> findClass(String name) throws ClassNotFoundException {
    throw new ClassNotFoundException(name);
}
```

因为ClassLoader是一个抽象，真正的加载逻辑需要具体的类加载器实现。因此，如果要实现自定义类加载器，继承ClassLoader,重写findClass就好了，主要任务获取class文件内容（字节数组），然后调用父类的defineClass获取Class实例。示例如下

```java
protected Class<?> findClass(String name) throws ClassNotFoundException {
    String base = "/xxx/";
    String namePath = name.replace(".", "/");
    System.err.println("name=" + name);
    try {
        byte[] classBytes = Files.readAllBytes(Paths.get(base + namePath + ".class"));
        return defineClass(name, classBytes, 0, classBytes.length);
    } catch (IOException e) {
        throw new ClassNotFoundException(name);
    }
}
```



双亲委派模型实现见`ClassLoader.loadClass`,核心逻辑如下


```java
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
				//先判断是否已经加载了  
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
          //委托上级类加载器加载，上级未找到会抛出ClassNotFoundException
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {//捕获之
            }

            if (c == null) {
              //尝试自己加载，如果没找到class文件，抛出ClassNotFoundException
                c = findClass(name);
            }
        }
        return c;
    }
```

如果自定义一个非双亲委派模型的类加载器，重写loadClass方法，直接自己加载关心的类。示例如下

```java
@Override
public Class<?> loadClass(String name) throws ClassNotFoundException {
    //如果不是自己关注的类，交由上级类加载器加载（自定义类加载的默认上级类加载器AppClassLoader）
    if (!name.startsWith("com.test")) {
        return super.loadClass(name);
    }

    //不遵守双亲委派模型，自己直接处理
    synchronized (getClassLoadingLock(name)) {
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            c = findClass(name);
        }
        resolveClass(c);
        return c;
    }
}

//可以直接在loadClass方法中实现findClass的逻辑，就不再重写findClass方法了
@Override
protected Class<?> findClass(String name) throws ClassNotFoundException {

    String base = "/xxx/";
    String namePath = name.replace(".", "/");
    System.err.println("name=" + name);
    try {
        byte[] classBytes = Files.readAllBytes(Paths.get(base + namePath + ".class"));
        return defineClass(name, classBytes, 0, classBytes.length);
    } catch (IOException e) {
        throw new ClassNotFoundException(name);
    }
}
```



双亲委派模型的意义



自定义类加载的意义



双亲委派模型的限制，以及非双亲委派模型实际应用场景





Tomcat在类加载方面的实践

目的，支持多个项目（java进程）系统类是要共享的，但是不同应用之间的类是各自的类加载器加载的







ClassNotFoundException和NoClassDefFoundError区别

