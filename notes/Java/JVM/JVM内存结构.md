

**运行时数据区域**

每部分作用范围（是否线程私有），存活时间，是否属于GC范围，是否会有内存溢出

* 程序计数器 Program Counter Register

  当前线程所执行字节码的行号指示器，每个线程独立存储。分支、循环、跳转、异常处理和线程恢复等基础功能都需要依赖这个计数器来完成。

* Java虚拟机栈 Java Virtual Machine Stacks

  线程私有，其生命周期与线程的相同。每个方法调用时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完的过程中，就对应着一个栈帧在虚拟机栈中的入栈和出栈过程。局部变量表存储了编译器已知的各种基本数据类型、对象引用，所以在方法运行期间不会改变局部变量大小。这个区域可能会出现两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverFlowError`;如果虚拟机栈可以动态扩展（大部分虚拟机都可以动态扩展），当扩展时无法申请到足够内存，会抛出`OutOfMemoryError`。

  > 方法中有多个分支，怎么确定局部变量表大小？
  >
  > https://zhuanlan.zhihu.com/p/45354152
  >
  > 

* 本地方法栈 Native Method Stack

  类似虚拟机栈，区别是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈为虚拟机调用本地方法服务。有的虚拟机（比如Hotspot）直接把本地方法栈和虚拟机方法栈合二为一。

* Java堆 Java Heap

  被所有线程共享的内存，用于存放对象实例。在虚拟机启动时创建，通过`-Xmx`和`-Xms`指定大小。如果没有足够内存完成实例分配并且也无法扩展了，会抛出`OutOfMemoryError`。

* 方法区 Method Area

  xxxx 还包括运行时常量池（Runtime Constant Pool）

* 直接内存 Direct Memory

  不属于虚拟机规范定义的内存区域，所以不属于GC负责范围。通过NIO

  

  

对象组成



对象创建流程



创建对象的方法







