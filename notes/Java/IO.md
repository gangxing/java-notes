NIO 

结合Linux 了解socket原理 什么多路复用 selector epoll poll 





时间： 1个星期(不知道什么时候创建的这些文件，反正感觉很久了，今天2019-11-14先初探一把)，学习参照

https://www.jianshu.com/p/486b0965c296

https://www.jianshu.com/p/aed6067eeac9

https://juejin.im/post/5c725dbe51882575e37ef9ed

[https://woshijpf.github.io/linux/2017/07/10/Linux-IO%E6%A8%A1%E5%9E%8B.html](https://woshijpf.github.io/linux/2017/07/10/Linux-IO模型.html)

### 背景知识一

**同步与异步**

`所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列`。要么成功都成功，失败都失败，两个任务的状态可以保持一致。

`所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了`。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，`所以它是不可靠的任务序列`。

如果异步调用，调用方获取异步任务结果方式

1. 设置共享数据，执行方执行完毕后将结果设置到该共享数据中，调用方不断轮询查询该共享数据

2. 执行方执行完毕后通知调用方

3. 执行方执行完毕后通过回调函数将结果告知调用方（这不也是一种通知方式吗？）

   

**阻塞与非阻塞**

**`阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。`**



`阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务`。函数只有在得到结果之后才会返回。

非阻塞和阻塞的概念相对应，`指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回`。虽然表面上看非阻塞的方式可以明显的提高CPU的利用率，`但是也带了另外一种后果就是系统的线程切换增加`。`增加的CPU执行时间能不能补偿系统的切换成本需要好好评估`。



> **同步/异步**讨论的是调用方获取任务执行结果的方式
>
> **阻塞/非阻塞**讨论的是调用方在等待任务结果时是否还能干其他事



按照上面两种维度来组合，就会有 *同步阻塞*， *异步阻塞*  ，*同步非阻塞* 和*异步非阻塞*四种实现方案





### 背景知识二

**用户空间与内核空间**

在32位操作系统中，寻址空间（虚拟地址）是2^32(4G),为了保证内核安全，禁止用户进程直接操作内核，操作系统将虚拟地址空间划分为两部分，将0xC0000000到0xFFFFFFFF（1G）划给内核使用，称为内核空间（也就是内核态？），剩余的0x00000000到0xBFFFFFFF（3G）划分给用户进程使用，称为用户空间（也就是用户态？）

> 那64位操作系统岂不是可以管理2^64(17179869184G)?理论上是这样的，但实际中目前只用到了48位(262144G)
>
> https://www.zhihu.com/question/28638698



**进程阻塞**

正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。`当进程进入阻塞状态，是不占用CPU资源的`。

### Linux IO模型

`网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作`。

> 像Java世界中切皆对象一样，Linux中一切皆文件。socket也是一个文件又是怎么体现的？
>
> https://blog.csdn.net/kingshown_WZ/article/details/52103327
>
> https://blog.csdn.net/YEYUANGEN/article/details/6799575
>
> 对于tcp传输，需要源IP/端口，目标IP/端口四元组，每创建一个连接（socket?），客户端端内核会随机分配一个端口，但是服务端只有一个端口，那对于多个连接，服务端是怎么确定该数据包属于一个进程中的哪个连接呢？

对于一次IO访问（比如read），数据会先被拷贝到操作系统**内核的缓冲区**中，然后才会从操作系统内核的缓冲区拷贝到**应用程序的地址空间**。所以，当一个read操作发生时，它会经历两个阶段：

1. 第一阶段：等待数据准备
2. 第二阶段：将数据从内核复制到进程中

对于socket流而言，

1. **第一步：等待网络上的数据分组到达，然后被复制到内核的某个缓冲区**
2. **第二步：将数据从内核缓冲区复制到应用进程缓冲区**

网络IO模型有以下5中

* 阻塞IO Blocking IO
* 非阻塞IO Non-Blocking IO
* 多路复用IO Multiplexing IO
* 信号驱动IO Signal Driven IO（实际中不常用）
* 异步IO Asynchronous IO 



#####一、Blocking IO

在这个模型中，用户进程执行一个系统调用(recv/recvfrom),这会导致进程阻塞（不占用CPU时间片），直到数据准备好，并将数据复制到进程缓冲区，最后进程再处理数据。这种模型从数据处理角度来讲是最及时的，因为数据被复制到进程缓冲区后，进程能及时处理。处理流程图如下：

![](https://static.oschina.net/uploads/img/201604/20150405_VKYH.png)



##### 二、Non-Blocking IO



##### 三、Multiplexing IO



##### 四、Asynchronous IO



##### 五、Signal Driven IO

