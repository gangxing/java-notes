为了解决多线程带来的并发问题，业界总结出的一套设计模式，类似缓存更新设计模式、23种设计模式一样

#####一、不可变模式 Immutability 

见String Integer，自己实现不可变类需要注意的点

1. 类定义成final（不允许被继承）
2. 所有属性设置成final，只提供get操作
3. 如果属性也是对象，则该对象也应该是不可变的
4. 构造时“逸出”？在构造器中将this赋值给全局变量，



##### 二、Copy-on-Write模式

改模式也是不可变模式的一种实现手段，比如string中的replace，实际上返回的是一个新的string对象

`CopyOnWriteArrayList`，`CopyOnWriteArraySet` ，写时复制思想就是在写的时候，赋值一份数据，写完后再赋值给原来的引用。这样能做到读时不加锁，但是新数据不会被立即读到。需要业务承受一定的时间的不一致的。

适用的场景：读多写少



##### 三、线程本地存储模式 

将共享资源进行线程封闭

* 放到线程方法内部

* Thread Local

  > Thread Local 实现原理，每个线程有个map，ThreadLocalMap，key是ThreadLocal实例，value是存放的值，这样就可以实现一个线程可以任意设置多个value

##### 四、GuardedSuspension模式

保护性暂停，等待唤醒机制的规范实现，典型场景：生产者消费者模型。

多线程版本的if 



#####五、Balking模式

Balking模式本质上是一种规范化地解决“多线程版本的if”的方案 ，

实现方案：

* 利用synchronized
* 利用volatile（如果对原子性没有要求）

#####六、Thread-Per-Message模式



#####七、两阶段终止模式



#####八、生产者消费者模式



