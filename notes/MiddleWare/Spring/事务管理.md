https://juejin.im/post/5b00c52ef265da0b95276091



##### Spring 通过`TransactionDefinition`主要定义了传播属性和隔离级别



事务的传播行为 PROPAGATION 为了解决业务层方法之间相互调用的事务问题
支持当前事务

**PROPAGATION_REQUIRED** (Spring默认的事务传播行为)如果调用方法存在事务，则加入当前事务，如果没有，则新建事务

**PROPAGATION_SUPPORTS** 如果存在， 则加入当前事务，不存在， 则以非事务方式继续运行
**PROPAGATION_MANDATORY** 如果存在, 加入当前事务， 如果不存在，则抛出异常

不支持当前事务
**PROPAGATION_REQUIRES_NEW** 自己创建新的事务， 如果当前已经有， 则挂起

> 挂起是什么意思？？？

**PROPAGATION_NOT_SUPPORTED** 以非事务方式运行， 如果当前存在事务， 则挂起
**PROPAGATION_NEVER** 以非事务方式运行，如果当前存在事务， 则抛出异常

其他情况
**PROPAGATION_NESTED** 如果当前存在事务 则创建一个事务作为档期内事务的嵌套事务来运行；如果当前没有事务，等价于PROPAGATION_REQUIRED

>  什么叫等价于？ 没有的话新建一个事务 跟嵌套不嵌套有什么区别？



#####Spring事务管理和MyBatis集成

从mybatis角度来讲，会用`SpringManagedTransaction`来获取一个事务定义（即事务管理交由Spring管理），那在哪里指定的呢？？？？

`TransactionSynchronizationManager`

mybatis提供的`SqlSessionFactoryBean` 中默认的transactionFactory是`SpringManagedTransaction`,源码如下

```java
if (this.transactionFactory == null) {
  this.transactionFactory = new SpringManagedTransactionFactory();
}
```



> 这里也提供了一个跟Spring集成，将自己的Bean 加入到Spring IOC容器中的例子。在SpringBoot中，即实现一个xxx-starter。mybatis-spring-boot-starter



##### 线程和Connection绑定

在MySQL层，必须在同一个连接中才能实现一组SQL共用同一个事务，所以Spring或者MyBatis就必须保证，在一个事务中，当前线程永远要获取到同一个Connection。这个逻辑是Spring还是MyBatis做的？核心逻辑是怎么实现的？

























分布式事务



