https://juejin.im/post/5b00c52ef265da0b95276091

https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html





##### Spring 通过`TransactionDefinition`主要定义了传播属性和隔离级别



事务的传播行为 PROPAGATION 为了解决业务层方法之间相互调用的事务问题
支持当前事务

**PROPAGATION_REQUIRED** (Spring默认的事务传播行为)如果调用方法存在事务，则加入当前事务，如果没有，则新建事务

**PROPAGATION_SUPPORTS** 如果存在， 则加入当前事务，不存在， 则以非事务方式继续运行
**PROPAGATION_MANDATORY** 如果存在, 加入当前事务， 如果不存在，则抛出异常

不支持当前事务
**PROPAGATION_REQUIRES_NEW** 自己创建新的事务， 如果当前已经有， 则挂起

> 挂起是什么意思？？？

**PROPAGATION_NOT_SUPPORTED** 以非事务方式运行， 如果当前存在事务， 则挂起
**PROPAGATION_NEVER** 以非事务方式运行，如果当前存在事务， 则抛出异常

其他情况
**PROPAGATION_NESTED** 如果当前存在事务 则创建一个事务作为当前内事务的嵌套事务来运行；如果当前没有事务，等价于PROPAGATION_REQUIRED

>  什么叫等价于？ 没有的话新建一个事务 跟嵌套不嵌套有什么区别？

> 前面6中传播属性是从EJB中引入的，PROPAGATION_NESTED是Spring所特有的，启动的嵌套事务只有通过外部事务的提交才能引起内部事务的提交，通过savePoint实现。 具体还是不太懂内外事务的提交回滚机制



#####Spring事务管理和MyBatis集成

从mybatis角度来讲，会用`SpringManagedTransaction`来获取一个事务定义（即事务管理交由Spring管理），那在哪里指定的呢？？？？

`TransactionSynchronizationManager`

mybatis提供的`SqlSessionFactoryBean` 中默认的transactionFactory是`SpringManagedTransaction`,源码如下

```java
if (this.transactionFactory == null) {
  this.transactionFactory = new SpringManagedTransactionFactory();
}
```



> 这里也提供了一个跟Spring集成，将自己的Bean 加入到Spring IOC容器中的例子。在SpringBoot中，即实现一个xxx-starter。mybatis-spring-boot-starter



##### 线程和Connection绑定

在MySQL层，必须在同一个连接中才能实现一组SQL共用同一个事务，所以Spring或者MyBatis就必须保证，在一个事务中，当前线程永远要获取到同一个Connection。这个逻辑是Spring还是MyBatis做的？核心逻辑是怎么实现的？

在数据库层，每条SQL都是运行在一个事务中的，要么用户指定事务的开启和结束，要么数据库为每条SQL自动开启事务和提交事务。但是在应用层，是可以指定某个方法(方法中的所有SQL)是运行在事务中还是不带事务。其实这里有点概念上的误导，Spring层的所谓带事务是指方法中的所有SQL运行在同一个事务中，而不带事务，则不显示指定事务的开启和提交/回滚，这样则由数据库为每条SQL自动开启事务和提交/回滚。

> 从上面来讲，在同一个事务中的所有SQL一定要在同一个connection中执行的，这是需要Spring来维护映射关系。如果Spring层不带事务，这个映射是否可以不用再维护了呢？
>
> 不管当前方法是否运行在同一个事务中，都讲当前"事务"绑定到当前线程（利用ThreadLocal实现）
>
> ```java
> // We always bind the TransactionInfo to the thread, even if we didn't create
> // a new transaction here. This guarantees that the TransactionInfo stack
> // will be managed correctly even if no transaction was created by this aspect.
> txInfo.bindToThread();
> ```



为了维护某条SQL是否在某个事务中，Spring层需要再维护一个“事务”概念，`TransactionStatus`,维护了Spring层“事务”的相关状态

```java

boolean isNewTransaction();

boolean hasSavepoint();

void setRollbackOnly();

boolean isRollbackOnly();

@Override
void flush();

boolean isCompleted();
```







业务中使用Spring对事务的管理能力，

1. 编程式事务管理，为业务Bean引入TransactionTemplate，在执行业务方法中，手动指定事务的开始、提交/回滚。这种方式的优点，业务层完全掌控事务的管理，可以很灵活地做改动。缺点，每个业务方法都需要手动编写事务管理逻辑，大部分情况下，这些逻辑都是一样的。

2. 声明式事务管理，利用AOP在业务方法执行前后实现事务的开启和提交/回滚。业务方法不用关心事务管理。

   声明式事务管理由`TransactionInterceptor`实现，需要自己装配，指定transactionManager和transactionAttributes。缺点，配置复杂。

3. 基于TransactionProxyFactoryBean的声明式事务管理

4. 基于 @Transactional 的声明式事务管理

   > 注解是基于Spring AOP实现的，而AOP又是基于动态代理(cglib或)
   >
   > 所以@Transactional 注解应该只被应用到 public 方法上

以上四种不同的使用方式，其背后的实现逻辑都是一致的。且看

`TransactionAspectSupport.invokeWithinTransaction()`

是怎么调用业务方法，又是在哪儿执行begin transaction,commit操作的?

在Spring Boot中，默认的事务管理器是`DataSourceTransactionManager`

从`TransactionSynchronizationManager`中获取一个Connection（ThreadLocal）

初次获取到的ConnectionHolder是null，

`AbstractPlatformTransactionManager.getTransaction`判断是否已存在事务，以及根据事务定义的传播属性分别处理。内部再调用`doBegin`

`DataSourceTransactionObject` transaction

`TransactionInfo`

获取一个connection，默认autoCommit=1,所以改成0（关闭自动提交）,则需要业务层显示commit,否则当前connection里的所有SQL都不会提交。

将connection绑定到当前线程

```java
// Bind the connection holder to the thread.
if (txObject.isNewConnectionHolder()) {
   TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());
}
```

执行完每条SQL后怎么确定整个事务是否要提交？？？

> 业务Bean（XXServiceImpl实现了接口）为什么还是要用cglib



```
invocation.proceedWithInvocation()
```



不关心一个事务中间的所有SQL，等带事务的方法执行完毕之后再统一commit。



分布式事务



