分布式相关

https://coolshell.cn/articles/10910.html

https://juejin.im/post/5cd69b1bf265da03b4462fd0



数据分区，解决单台机器容量上限问题

数据冗余(副本)，解决高可用问题。

为了解决高可用，就需要冗余，有了冗余后，就有了数据一致性问题，即分布式事务。如果只是为了保证一致性，倒不是很难，但还需要考虑在一致性前提下的性能，



- XA 方案
- TCC 方案
- 本地消息表
- 可靠消息最终一致性方案
- 最大努力通知方案

#####XA方案（2阶段提交方案）

一个**事务管理器**协调多个数据库，第一阶段、事务管理器询问各事务是否可以提交，如果都回复可以则统一提交；否则，回滚各个本地事务。？？

优点：实现简单，依赖数据库本身的XA Transactions即可

缺点：事务管理器单点，性能低，只适合单个服务操作多个数据库



##### TCC

 Try

对各个服务的资源做检测以及对资源进行锁定或者预留。

 Confirm

各个服务执行实际的操作。

 Cancel

如果任意一个服务的业务方法执行出错，需要大家进行补偿（提供逆向接口）

有点：能够实现强一致性

缺点：编码复杂（每种操作要提供正向、逆向两套接口），还需要保证接口幂等，如果try未提交，则cancel就不用执行了。

> TCC 谁在中间调控

##### 本地消息表

1. A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；
2. 接着 A 系统将这个消息发送到 MQ 中去；
3. B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样**保证不会重复处理消息**；
4. B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；
5. 如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；
  

每个分支事务将数据记录到数据表中，表示事务执行状态（是否执行成功了）



##### 可靠消息最终一致性方案

不再用本地消息表来存储事务状态，只用MQ发送事务指令？

1. A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；

2. 如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；

3. 如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；

4. mq 会自动**定时轮询**所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行（也可以借助redis等内存数据库存储事务的执行状态），如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。

5. 这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。

> 各个本地事务串行执行，MQ通过重试(轮询prepared消息)通知未完成的事务，尽可能让后面的事务执行成功，实在不行则让前面的事务回滚。
>
> 后面的事务也要保证幂等，因为可能存在事务执行成功了，但是确认消息发送失败，MQ会重试。

   

#####最大努力通知方案

1. 系统 A 本地事务执行完之后，发送个消息到 MQ；

2. 这里会有个专门消费 MQ 的**最大努力通知服务**，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；

3. 要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。

   > 和可靠消息最终一致性方案相比，重试工作独立开来由单独的服务执行，而不再由MQ来承担这项工作？
   >
   > 如果达到重试次数还是未成功，则需要人工介入修正？

