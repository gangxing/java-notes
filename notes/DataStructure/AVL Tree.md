**平衡二叉树(AVL Tree)**

Self-balancing Binary Search Tree, 

根据[维基百科]([https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E6%A0%91](https://zh.wikipedia.org/wiki/平衡树))AVL树得名于它的发明者[G. M. Adelson-Velsky](https://zh.wikipedia.org/wiki/格奥尔吉·阿杰尔松-韦利斯基)和Evgenii Landis，他们在1962年的论文*An algorithm for the organization of information* 中公开了这一数据结构。

AVL 是一种高度平衡的BST，所谓平衡，通俗来讲，任何一个节点的左右子树的节点数尽肯能相等。更准确的描述：<font color="#dd0000">任何一个节点的左右子树的高度差的绝对值不超过1</font>

AVL 的查找能达到二分查找法的效果，这是在新增和删除节点过程中，通过付出修正树的平衡之代价换来的。跟BST相比，关键在于保证树的平衡性的实现。要维护平衡性，第一个问题是如何判定树是否满足平衡性，第二个问题，如果判断不平衡了，怎么修正。参照[这篇文章](https://www.cnblogs.com/huangxincheng/archive/2012/07/22/2603956.html)了解之。

针对第一个问题，从一个节点开始，递归往下查找一直到叶子节点，计算出其左右子树的高度，如果两者相差超过1，则树已经不平衡了。因为递归计数得出任意子树的高度比较耗时，所以在具体实现中不可能从根节点开始，应该从新增（或删除）的节点开始，逐级往上判定每个父节点，如果某个父节点的左右子树高度差超过1，则该节点称之为<font color="#dd0000">失衡节点</font>。

第二个问题，修正的手段，<font color="#dd0000">左旋</font>、<font color="#dd0000">右旋</font>。以右旋为例解释

![](https://cdn.sinaimg.cn.52ecy.cn/large/005BYqpgly1g5mm8a46nlj30b6048wek.jpg)

以蓝色方框中三个节点为单元，红色折线上节点按照箭头方向向前移一位。打个不恰当的比喻，类似一串珠子，固定三角排列，在右边往下拉了一下。左旋是反向操作，见下图

![](https://cdn.sinaimg.cn.52ecy.cn/large/005BYqpgly1g5mnf8v8azj30b6048glq.jpg)

这里的旋转有点不好理解，叫左拉和右拉就好理解啦，哈哈哈哈。

在实际的旋转过程中，不一定刚好是三个节点，有可能只有两个(没有1节点),有可能有多个，比如2有两个子节点。但不影响对旋转操作的理解。后面遇到了这些特殊情况再细讲。

到此，解决了怎么判定树失衡了，即是否存在失衡节点，如果有，通过左旋或右旋手段修正之。实际情况中，失衡节点的左右子树除了上面两种情况外，还有如下几种。

一个下午就整理除了一个二叉搜索树和半篇平衡树，好费时间。。。。。20190803 后面继续。。。。

因为每次新增节点或删除节点，都会校验树是否失衡并且修正之。所以，每次改变树结构后，最多只会出现一个失衡节点。因此，改变树结构后，第一步找到失衡节点，如果有，只会出现下面四种情况

1.LL型

![](https://pic002.cnblogs.com/images/2012/214741/2012072218213884.png)

节点的左子树的左节点致使该节点成了失衡节点

2.RR型

![](https://pic002.cnblogs.com/images/2012/214741/2012072218444051.png)

节点的右子树的右节点致使该节点成了失衡节点

3.LR型

![](https://pic002.cnblogs.com/images/2012/214741/2012072219144367.png)

节点的左子树的右节点致使该节点成了失衡节点

4.RL型

![](https://pic002.cnblogs.com/images/2012/214741/2012072219540371.png)

节点的右子树的左节点致使该节点成了失衡节点

现在要解决的问题

1.确认失衡节点并判断其失衡类型

2.修正

每个节点维护一个字段`height`,代表这个节点所处的高度，即以这个节点为根节点的子树的高度。

问题：如果树增加或减少了高度，所有非叶子节点都需要更新这个值？？？？成本也太高了吧。。。

这种方案感觉也不太好，再重新找找，[这篇](https://segmentfault.com/a/1190000006123188)还不错，也是java实现

AVL树节点新增的属性

2.parent-父节点 

树(子树)的高度计算：从树(子树)根节点开始，递归查下去累计计数得到。如果根节点不存在，即一棵空树的高度是-1，实现如下

```java
private int height(Node n) {
    if (n == null)
        return -1;
    return 1 + Math.max(height(n.left), height(n.right));
}
```

先按照二叉搜索树的插入操作增加新的节点，然后找到离新增节点最近的失衡节点（需要向上找，所以需要持有父节点的引用？）。balance==2或-2时这个节点即为失衡节点，平衡之，然后递归向上再平衡之，直至不再有失衡点

又搞了一下午，终于把平衡二叉搜索树的添加节点操作实现了

四种基本类型

LL型，右旋修正

![](https://cdn.sinaimg.cn.52ecy.cn/large/005BYqpgly1g4zfz9zl2wj30b504s0st.jpg)



RR型，左旋修正

![](https://cdn.sinaimg.cn.52ecy.cn/large/005BYqpgly1g4zg6z2gkoj30c904wmx9.jpg)

RL型，先对子树进行右旋，再对包括失衡节点的子树进行左旋



![](https://cdn.sinaimg.cn.52ecy.cn/large/005BYqpgly1g4zgzrr5o9j30fl03qweo.jpg)

当新增一个节点时，如果没有兄弟节点，才有可能产生失衡节点。

搞了一天，对左旋和右旋有点似懂非懂

在二叉树中，以左中右三个节点为一个单位，将这个三角形想象成一个管道，所谓左旋，将三个或两个节点逆时针向前移动一位。因为这三个节点满足递增或递减顺序，所以，当移动三个点时，要满足LL或RR型，否则先将后面两个节点拉直，然后再左旋或右旋。

