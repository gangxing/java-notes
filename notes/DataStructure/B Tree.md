B Tree

**B树**

[图文讲解](https://www.cnblogs.com/nullzx/p/8729425.html)

[代码实现](https://blog.csdn.net/wangpingfang/article/details/7426943)

持久化树，[mapdb](https://github.com/jankotek/mapdb/),后面了解是怎么处理内存中的对象引用的。



B树也称B-树,它是一颗多路平衡查找树。我们描述一颗B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母m表示阶数。当m取2时，就是我们常见的二叉搜索树。

为方便描述，先明确几个概念。

> 键值对(Entry)：称key-value为Entry
>
> 
>
> 节点(Node)：1个或多个键值对组成一个节点
>
> 根节点(Root Node)：在树顶端的那个节点
>
> 叶子(Leaf Node)：在树底部(最底一排)的节点
>
> 内节点(Inner Node)：非根节点，非叶子节点的节点

数量概念

> 子节点（子树）数量 - Child Count, 简写为CC
>
> 节点内键值对数量 - Entry Count,简写为EC
>
> 且满足CC=EC + 1



参照[维基百科](https://zh.wikipedia.org/wiki/B树#名字取义)一颗m阶的B树有如下约束

> 1.每个内节点最多有m个子节点，即CC <=m -> EC+1 <=m -> EC <= m-1
>
> 2.每个内节点最少有[m/2]个子节点，综合1则有：EC -> [ceil(m/2)-1,m-1]
>
> 3.如果根节点不是叶子节点，则根节点至少有两个子节点（如果因为删除子节点导致根节点只有一个子节点了，则需要合并，将原先的根节点下放到叶子节点层去）
>
> 4.每个节点中key都按照从小到大的顺序排列，每个key的左子树中的所有关键字都小于它，而右子树中的所有key都大于它。(这点跟二叉搜索树相似)
>
> 5.所有叶子节点都位于同一层，根节点到任何叶子节点的路径长度都相同（即树的高度）。
>
> 例子，假如m=5,则EC的值有：2，3，4个？？？？

至于m在实际开发中怎么确定，只要遵循一个原则：一个节点上m-1个数据的大小总和跟磁盘的一页(block size)尽可能接近就好。一般根节点常驻内存，其余节点被更新后，立即存到磁盘，需要的时候，一次读出来。这就是上面的m取值原则的原因所在。加入m为1000，一棵高度为2(3层)的B树就可以存10亿条数据,计算如下：

根节点：1000条

第二层：1000*1000 = 10万条

第三层：1000\*1000\*1000=10亿



###### 新增操作

根据上面对B树的定义，添加Entry的逻辑如下：

> 1.









怎么实现树的增长规则和删除节点规则，什么时候增加层数，什么时候在一个节点上增加key

插入 分裂。。。。。明天继续。。

> 2019-10-17号，我又来了，时间起码过去了一个多月了又。

