从传输层了解一次接口请求，数据包的收发流程。三次握手、传输数据、四次挥手，TCP传输控制协议

利用到的工具tcpdump

TCP Transmission Protocol相关概念

* TCP数据包标志位

  > SYN -建立连接请求
  >
  > ACK-确认
  >
  > PSH-发送数据
  >
  > FIN-断开连接
  >
  > RST-连接复位？？强制断开

* ISN

  > Initial Sequence Number

* MSS

  >Maximum Segment Size

* MSL

  > Max Segment Lifetime

* WIN

  > Window size

* TTL？怎么定义的表示 https://blog.csdn.net/zhongguoren666/article/details/7377732
* 超时重传 超时时间是怎么定义的？



图（待完善）

![network-request-reponse-packets.png](https://i.loli.net/2019/11/07/xid5yZD4soPJLNw.png)



数据包格式见[TCP数据包格式](./TCP%e6%95%b0%e6%8d%ae%e5%8c%85%e6%a0%bc%e5%bc%8f)

https://blog.csdn.net/smileiam/article/details/78226816这篇文章写得还比较详细



**客户端TCP状态迁移**
CLOSED->SYN_SENT->ESTABLISHED->FIN_WAIT_1->FIN_WAIT_2->TIME_WAIT->CLOSED
**服务端TCP状态迁移**
CLOSED->LISTEN->SYN收到->ESTABLISHED->CLOSE_WAIT->LAST_ACK->CLOSED



学习完理论，再对照实际中验证

```shell
tcpdump -i any -nnS -s 0 host xxx.com and port 8080
```



![server-finish-twice.png](https://i.loli.net/2019/11/08/luhfaEAonTXKdwI.png)



通过多次抓包发现以下三个不符合理论的地方

1. 客户端和服务端关闭连接发送的是FIN,ACK，而不仅仅是FIN
2. 服务端没有为客户端的FIN发送ACK
3. 服务端会发送两次FIN,ACK（客户端也跟着回了两次ACK）
4. 服务端发送了两次RST



我的天，跟理论这么多不一致！！！换个环境试试

涛声依旧啊 

https://www.nowcoder.com/questionTerminal/187fad4ebd7a44f09d75c4c63e7e35ac

关于ACK和FIN在同一个包里是由于TCP协议特有的延时应答和捎带应答机制，延时应答保证了数据的传输最大化。

两边都主动提出关闭，并不是一定客户端先提出断开连接，而后服务端再提出断开连接？



> 什么时候会发送RST呢，发送完RST包后，该条连接在发送端这里就算是断开了吗？



PSH只代表在向缓冲中写数据，并不代表数据正在网络中传输



感觉是服务端在实现上做了什么优化？

自己写一个纯粹的Socket

这下好了，三次握手的包也都会发两次？？？？？

这可能是服务端和客户端两边都看到的？？

将服务端部署在远端





服务端第二次握手不是发送的SYN+ACK 而是RST+ACK,客户端方面，抛出了java.net.ConnectException: Connection refused (Connection refused)

是因为服务端根本没有监听这个端口

修正了端口，都是9527，还是refused,通过netstat -natp 

![image-20191111111222650](/Users/xgang/Library/Application Support/typora-user-images/image-20191111111222650.png)



发现Local Address有些不一样，这表示值监听本地来的包？如果是非本地的，则直接拒绝？？？

![](https://img-blog.csdn.net/20171107152033148?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSjA4MDYyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

终于通了，Server端，不要指定ip，否则，只能监听来自于特定ip的包，否则会直接拒绝

最后会因为两端各自关闭连接的时机各种各样，所以发送的包不一定是标准的四次挥手？

在我的例子中，用的Java，调用outputStream.close()内部不一定是上面标准的调用顺序，所以用C来实现

https://blog.csdn.net/Leafage_M/article/details/78459799

妈的 只是想要一个demo跑通socket 怎么这么难

算了 后面再研究C 还是从java层面来了解

关于socket 这篇文章还不错

https://www.jianshu.com/p/cde27461c226

绕了一圈，感觉跑偏了，先回到主题上来，从理论层面弄清楚











