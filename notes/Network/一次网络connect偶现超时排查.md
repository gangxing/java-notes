问题现象 客户端请求接口时不时出现connect超时



先来一个三次握手的时序图

![handshake.png](https://i.loli.net/2019/10/30/2mNDL4kBVvHJ7df.png)

利用tcpdump查看一次接口请求的流程

一、DNS解析

二、建立连接（三次握手）

三、传输请求数据

四、服务端处理

五、传输响应数据

六、断开连接（四次挥手）





> 1.状态流转 ESTABLISHED LISTEN CLOSED TIME_WAIT .......
>
> 2.每种过程中，服务端核心操作是什么
>
> 3.连接超时，是从哪个时刻开始计时的
>
> 4.连接超时，如果网络通顺，服务端可能的问题
>
> 5.构建一个服务端，使连接超时
>
> 6.序列号(ISN)真的是随机生成的吗
>
> 32位无符号整型，所以ISN可表示0-4294967295(2^32-1)
>
> 刚开始是随机生成的，后续每秒钟按照固定步长增加。
>
> 关于端口，客户端 每个连接单独分配一个 这样就可以将接收的数据放到正确的buffer中？
>
> 那服务端呢？也是吗
>
> 关于标志位 服务端向客户端发数据 ACK
>
> 客户端向服务端发数据 PSH ACK 



在早期IPv4地址资源充足的情况下，利用PAWS机制可以快速回收掉TIME_WAIT状态连接。

PAWS机制是通过TCP中携带客户端时间戳，当服务器主动关闭并快速TIME_WAIT状态socket之后，如果相同再次连接请求，但是携带的时间戳小于刚刚被关闭的链接中的时间戳，则该连接请求在60秒内会被拒绝。此举是为了防止旧包扰乱连接状态。在早期IPv4地址资源充足的情况下，一个IP代表的就是一个物理机。但是随着互联网发展，IPv4资源日趋紧缺，则有了NAT转换，多个客户端共用同一个外网IP。此时相同的IP背后代表着不同的客户端主机，刚好时间戳是各自生成的，无法保证同步。这就产生了真的新连接请求包可能会因为时间戳问题被服务端认为是过期的包。但是这种情况是随机的，所以客户端表现出时而连接顺畅，时而连接不上的现象。



在我们的实际场景中，多个测试机都是在同一个局域网下，正好符合这种情况。

所以当服务器处理来自经过NAT转换的IP包时，需要关闭net.ipv4.tcp_tw_recycle。

但是基于这个机制产生的背景，依旧适合用户处理来内内网（每个机器都有独立的内网IP），还是能够享受到快速关闭TIME_WAIT状态的socket链接和防止旧IP包扰乱连接状态。

