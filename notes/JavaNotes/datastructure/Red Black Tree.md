Red Black Tree

**红黑树**

[学习参照](https://blog.csdn.net/v_JULY_v/article/details/6105630)

我的天呐，看得脑阔疼，再看三遍。。。。

红黑树本质上也是一颗二叉搜索树。

为什么会有红黑树的出现，二叉搜索树只有在高度平衡时才能达到二分搜索的效果，所以最直接的就有了平衡二叉树，满足了二分查找的条件，但是每次添加或删除节点时都严格维护树的平衡性，所以添加或删除节点的维护成本较高。所以在树的平衡性和维护成本之间找一个折衷方案，前辈们提出了红黑树的概念。先看看红黑树的5个性质：

1.节点是红色或黑色的。ps:每个节点都有颜色，并且是红黑两者中的一个，标记颜色有什么用？？？

2.根节点是黑色

3.每个叶节点都是黑的。这里的叶节点是指树尾端NIL指针或NULL指针

4.如果一个节点是红的，那么它的两个子节点都是黑的。（这里可没说一定要红黑相间额！！！任意一条路径上，没有连续的红节点，有可能会出现连续的黑节点）

5.对任意节点而言，其到树尾NIL或NULL节点的每一条路径上的黑节点数量一致

```java
正是红黑树的这5条性质，使一棵n个结点的红黑树始终保持了logn的高度，从而也就解释了上面所说的“红黑树的查找、插入、删除的时间复杂度最坏为O(log n)”这一结论成立的原因
```

红黑树近似平衡二叉树，也就是说不是严格的平衡二叉树，作何理解？？？？因为通过图，看到红黑树也是严格的平衡二叉树呢

特性4和特性5保证了：<font color="#dd0000">从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。</font>

论证：因为特性5限制了每条路径上黑节点数量一致，导致路径不同就看红节点贡献的长度。特性4限制了不能有连续的红节点，所以最长的路径上红点最多的情况是红黑相间，即红节点数量等于黑节点数量，最短路径上没有红点。所以最长路径不会超过最短路径的2倍。



找了半天，还是发现[维基百科](https://zh.wikipedia.org/wiki/红黑树)讲得透彻，这种严谨、完整的叙述方式值得学习

红黑树高度计算



为什么红黑树的高度不会超出logn

[这篇](https://www.cnblogs.com/skywang12345/p/3245399.html)讲的是`一棵含有n个节点的红黑树的高度至多为2log(n+1)`



**增加操作**

先按照二叉搜索树将数据放在红节点插入到树中，为了满足红黑树的5个性质，再执行变更颜色或旋转节点操作

每次插入，特性1和特性3天然满足，只需关心根节点是黑色，不能有连续红节点，黑节点数量相同这三个特性。

有5中情形

*1.新节点没有父节点（新节点是根节点）*

只需变更颜色为黑色即可

*2.新节点的父节点是黑色*

这种场景不会破坏红黑树的特性，无需额外操作。下面逐一论证下

因为父节点是黑色，满足特性4，所以不需要变更颜色，因此便没有增加黑节点的数量，所以特性5依旧满足。

*3.新节点的父节点是红色*

这种场景隐含的条件，新节点一定有祖父节点，因为根节点必须是黑色。

后面两种场景太难理解 看看JDK的`TreeMap`怎么实现的,天呐，代码那么长。。。`HashMap`中也用到了红黑树，但是和`TreeMap`没有复用树的相关代码。

JDK的代码没有注释，变量名也很短，看求不懂，还是只有慢慢啃逻辑，弄清插入逻辑后再去看JDK实现

难点在于对插入节点后，需要修复的场景理不清，终于又找到了[一篇](https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md),它对于插入时的场景归纳为3种，其实也是5种，只不过后面3种场景说得更简洁一点

为了行文更简洁，每种节点以字母命名

N-新增节点Node

P-父节点Parent

G-祖父节点Grandparent

U-叔父节点Uncle

LS-左兄弟节点Left Siblling

RS-右兄弟节点Right Siblling

LC-左子节点Left Child

RC-右子节点Right Child

各种场景需要示意图

*<font color="#dd0000">1.N为根节点</font>*

将N改为黑色即可

*<font color="#dd0000">2.N的P为黑色</font>*

没有改变原有的树结构，不修正

*<font color="#dd0000">3.N的P和U都是红色</font>*

这时G一定存在，并且是黑色。先将P和U改为黑色，再将G改为红色。如果G为根节点，改回黑色，否则，继续将G作为新插入的节点往上验证，直至不满足场景3

<font color="#6495ed">p.s.还得考虑N和P作为子节点身份来讲是RC还是LC。两两组合又得分四种情况。至于修正逻辑是否需要区分，先按照一种情况实现后再校验其他三种情况。</font>

*<font color="#dd0000">4.N的P是红色，U(可能是NIL)是黑色，P是LC,N是LC</font>*

以G为顶点右旋，P和G的颜色对换（P改为黑色，G改为红色），P代替了G，颜色最终也是黑色，所以对上没有变动，对下，没有增加黑色节点数量，所以也无需再做修正

*<font color="#dd0000">5.N的P是红色，U(可能是NIL)是黑色，P是LC,N是RC</font>* 

先以P为顶点左旋，转换成场景4，再按照场景4的流程修正

<font color="#6495ed">p.s. 这种操作有点类似于平衡二叉树，先将三个节点旋转到一条直线上，再继续后续操作</font>

*<font color="#dd0000">6.N的P是红色，U(可能是NIL)是黑色，P是RC,N是RC</font>*

此种场景是4的镜像

以G为顶点左旋，P和G的颜色对换（P改为黑色，G改为红色），P代替了G，颜色最终也是黑色，所以对上没有变动，对下，没有增加黑色节点数量，所以也无需再做修正

*<font color="#dd0000">7.N的P是红色，U(可能是NIL)是黑色，P是RC,N是LC</font>*

此种场景是5的镜像

先以P为顶点右旋，转换成场景6，再按照场景6的流程修正



ps花了一天的时间，终于把红黑树的插入实现了，

下一步实现删除操作，推导树的高度

**删除操作**



**查询操作 **

同二叉搜索树的查询



**迭代**

同二叉搜索树的迭代



**高度计算**

维基百科

包含*n*个内部节点的红黑树的高度是O(log$$n$$)。

**定义**：

- $$h(v)$$表示以节点 $$v$$为根的子树的高度。
- $$bh(v)$$表示从$$ v$$到子树中任何叶子的黑色节点的数目（如果$$v$$是黑色则不计数它，也叫做黑色高度）。

**引理**：以节点{\displaystyle v}![v](https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597)为根的子树有至少{\displaystyle 2^{bh(v)}-1}![2^{{bh(v)}}-1](https://wikimedia.org/api/rest_v1/media/math/render/svg/bd20e4a4bb09ff8a0b1f669e13d80a767fd380dc)个内部节点。

引理的证明（通过归纳高度）：

基础： $$h(v)=0$$

如果 $$v$$的高度是零则它必定是NIL，因此 $$bh(v)=0$$。所以：

$$2^{bh(v)}-1=2^{0}-1=1-1=0$$

归纳假设：$$h(v)=k$$的$$ v$$有$$ 2^{bh(v)-1}-1$$个内部节点暗示了$$h(v) = k+1$$的 $$v'$$有 $$2^{bh(v')}-1$$个内部节点。

因为$$v'$$有$$h( v')> 0$$所以它是个内部节点。同样的它有黑色高度要么是$$bh( v')$$要么是$$bh(v')-1$$（依据 $$v'$$是红色还是黑色）的两个儿子。通过归纳假设每个儿子都有至少 $$2^{bh(v')-1}-1$$个内部接点，所以$$v'$$有：

$$2^{bh(v')-1}-1+2^{bh(v')-1}-1+1=2^{bh(v')}-1$$

个内部节点。

使用这个引理我们现在可以展示出树的高度是对数性的。因为在从根到叶子的任何路径上至少有一半的节点是黑色（根据红黑树性质4），根的黑色高度至少是$$\frac{h(root)}{2}$$。通过引理我们得到：

![n\geqslant 2^{{{\frac  {h(root)}{2}}}}-1\leftrightarrow \;\log {(n+1)}\geqslant {\frac  {h(root)}{2}}\leftrightarrow \;h(root)\leqslant 2\log {(n+1)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/16f0c429691a200154c7dcd7b81ae57266f01440)

因此根的高度是$${\text{O}}(\log n)$$

