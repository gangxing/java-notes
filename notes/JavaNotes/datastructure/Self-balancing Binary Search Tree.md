Self-balancing Binary Search Tree

**平衡二叉树**

Self-balancing binary search tree

何为平衡，通俗来讲，任何一个节点的左右子树的节点数尽肯能相等。更准确的描述：

<font color="#dd0000">**任何一个节点的左右子树的高度差的绝对值不超过1**</font>

[学习来源](https://www.cnblogs.com/suimeng/p/4560056.html)

要维护平衡性，第一个要解决的问题就是怎么快速判定是否满足平衡性，

第二个问题，如果判断不平衡了，怎么修正

越看越复杂，重新找了[一篇](https://www.cnblogs.com/huangxincheng/archive/2012/07/22/2603956.html),感觉讲得还不错

因为每次新增节点或删除节点，都会校验树是否失衡并且修正之。所以，每次改变树结构后，最多只会出现一个失衡节点。因此，改变树结构后，第一步找到失衡节点，如果有，只会出现下面四种情况

1.LL型

![](https://pic002.cnblogs.com/images/2012/214741/2012072218213884.png)

节点的左子树的左节点致使该节点成了失衡节点

2.RR型

![](https://pic002.cnblogs.com/images/2012/214741/2012072218444051.png)

节点的右子树的右节点致使该节点成了失衡节点

3.LR型

![](https://pic002.cnblogs.com/images/2012/214741/2012072219144367.png)

节点的左子树的右节点致使该节点成了失衡节点

4.RL型

![](https://pic002.cnblogs.com/images/2012/214741/2012072219540371.png)

节点的右子树的左节点致使该节点成了失衡节点

现在要解决的问题

1.确认失衡节点并判断其失衡类型

2.修正

每个节点维护一个字段`height`,代表这个节点所处的高度，即以这个节点为根节点的子树的高度。

问题：如果树增加或减少了高度，所有非叶子节点都需要更新这个值？？？？成本也太高了吧。。。

这种方案感觉也不太好，再重新找找，[这篇](https://segmentfault.com/a/1190000006123188)还不错，也是java实现

AVL树节点新增的属性

2.parent-父节点 

树(子树)的高度计算：从树(子树)根节点开始，递归查下去累计计数得到。如果根节点不存在，即一棵空树的高度是-1，实现如下

```java
private int height(Node n) {
    if (n == null)
        return -1;
    return 1 + Math.max(height(n.left), height(n.right));
}
```

先按照二叉搜索树的插入操作增加新的节点，然后找到离新增节点最近的失衡节点（需要向上找，所以需要持有父节点的引用？）。balance==2或-2时这个节点即为失衡节点，平衡之，然后递归向上再平衡之，直至不再有失衡点

又搞了一下午，终于把平衡二叉搜索树的添加节点操作实现了

四种基本类型

LL型，右旋修正

![](https://cdn.sinaimg.cn.52ecy.cn/large/005BYqpgly1g4zfz9zl2wj30b504s0st.jpg)



RR型，左旋修正

![](https://cdn.sinaimg.cn.52ecy.cn/large/005BYqpgly1g4zg6z2gkoj30c904wmx9.jpg)

RL型，先对子树进行右旋，再对包括失衡节点的子树进行左旋



![](https://cdn.sinaimg.cn.52ecy.cn/large/005BYqpgly1g4zgzrr5o9j30fl03qweo.jpg)

当新增一个节点时，如果没有兄弟节点，才有可能产生失衡节点。

搞了一天，对左旋和右旋有点似懂非懂

在二叉树中，以左中右三个节点为一个单位，将这个三角形想象成一个管道，所谓左旋，将三个或两个节点逆时针向前移动一位。因为这三个节点满足递增或递减顺序，所以，当移动三个点时，要满足LL或RR型，否则先将后面两个节点拉直，然后再左旋或右旋。

