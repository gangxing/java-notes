Binary Search Tree

所谓二叉搜索树，其性质

二叉，每个节点最多只有2个节点，左节点和右节点

有序，每个节点的值大于其左节点的值，小于其右节点的值

按照中序遍历，可得一个递增数列。二叉查找树的查找可以实现类似于有序数列的二分查找，前提是树比较平衡（对称），即每个节点左子树和右子树的节点数相当。二叉查找树的对称性跟插入顺序有关，最坏的情况是按递增或递减序列插入，此时二叉树退化成一个链表。

二叉查找树的删除操作，三种情况

删除的节点没有子节点：将其父节点对其的引用置为空即可

删除的节点只有一个节点：将其父节点对其的引用置换成其子节点的引用即可

删除的节点有两个子节点：

二叉搜索树（二叉排序树）按照中序遍历是一个递增数列，如果删除一个节点后也需要满足中序遍历仍然能得到一个递增数列。所以删除后的节点要用其前驱节点或后继节点来占位，即数列中的前一个或后一个节点。

所谓前驱节点，在树中的表述为当前节点的左节点，左子树中最大的节点，即左子树的最右叶子节点

所谓后继节点，右子树中最小的节点，即右子树的最左叶子节点。

那具体用哪一种都一样

**迭代操作**

按照中序迭代，即递增返回节点。`hasNext()`和`next()`的平均时间复杂度为O(1),如果是这样，肯定需要额外的存储空间，[参照](https://zhuanlan.zhihu.com/p/27679447)

```
维护一个栈，从根节点开始，每次迭代地将根节点的左孩子压入栈，直到左孩子为空为止。

调用next()方法时，弹出栈顶，如果被弹出的元素拥有右孩子，则以右孩子为根，将其左孩子迭代压栈。
```

栈可以用`ArrayDeque` ,暂且不关心其实现原理。 FILO

实现还是蛮简单的，所需要的空间复杂度为O(h),h为树的高度

初始化迭代器

```java
public TreeIterator() {
    stack = new ArrayDeque<>();
    //从根节点开始，所有左节点组成的路径一次压入栈
    Node<V> parent = root;
    pushAll(parent);
}
```



将一个节点开始的左节点路径上的所有节点压入栈，

```java
private void pushAll(Node<V> parent) {
    while (parent != null) {
        stack.push(parent);
        parent = parent.left;
    }
}
```



实现`hashNext()`,只要栈不为空，并且下一个就是置于栈顶的节点

实现`next()`,取出栈顶节点后，如果当前节点有右节点，则以右节点为根节点，将其左节点链路上的所有节点压入栈，这里有点递归的味道，实现逻辑如下

```java
public Integer next() {
    Node<V> cur = stack.poll();
    //以cur为根节点，找出下一个
    if (cur == null) {
        throw new NoSuchElementException("已经没有啦，为什么还要来取");
    }
    //更新next
    if (cur.right != null) {
        pushAll(cur.right);
    }
    return cur.key;
}
```

至此，搜索二叉树的常规操作都实现了，虽然每种操作都还有更优秀的实现方案，比如迭代可以不用栈作为额外的辅助空间，给叶子节点添加前驱和后继两个节点的引用。不过这些都有点类似于茴香豆的茴有几种写法的味道，暂且不表。



搜索二叉树便于搜索的前提是树的平衡性足够好，才能达到类似于二分查找法，每次遍历到一个节点都能过滤掉另一半的节点。所以能不能做到，在保证树遍历的递增前提下，在每次添加或删除节点后，尽可能维持树的平衡。接下来看看所谓的平衡二叉树是不是为了解决这个问题的，而后再看它又是怎么解决的

