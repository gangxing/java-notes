在逻辑架构中，知道了select语句的执行流程，那update的执行流程如下：

1.连接数据库

2.清除该张表的所有缓存

> P.S. 所以不建议开启MySQL的缓存功能。

3.词法解析和语法解析

4.找到目标行(Row)调用存储引擎更新之

上面是和select相同的部分，更新流程中还维护这两套日志,binlog和redo log,还有undo log? 



> [日志详解](https://www.cnblogs.com/f-ck-need-u/p/9010872.html)

**binlog**

Server 层记录的日志，有Statementg、Row和mixed三种格式。简单理解binlog记录是所有更新SQL。物理文件

**redo log**

InnoDB引擎用于保证事务的实现方式，记录的是“数据页的修改”，redo log是固定大小的物理文件，通过write position 和 check position两个值控制写入和擦除日志。先写日志再将数据写入磁盘，这就是所谓的WAL(Write Ahead Log)技术。MySQL每次重启的时候，都会从redo log中恢复数据，有了redo log, MySQL就拥有了crash safe能力。

> 1.这就是持久性的实现机制吗？
>
> 2. redo log 是先写入buffer中，



**undo log**

是用于支持事务回滚和MVVC(Multi Concurrency Version Control)的逻辑日志。记录的是binlog的反向操作SQL。当事务回滚的时候，执行undo log中的反向SQL回滚数据。在并发事务下，加入事务隔离级别是REPEATABLE_READ，则在事务未提交之前，任何时刻看到的数据都是不变的，即便是被其他事务更新了。这是因为执行undo log的反向SQL到事务开启的时刻，提供的一个版本。所以多版本并不是真正将数据存了多份。

基于日志的概念，一条更新SQL，比如`update T set c=c+1 where ID=2;`,其执行流程如下图所示

<img src="https://i.loli.net/2019/10/15/l6VcTPtui98mLHw.png" alt="sql-update-process.png" style="zoom: 40%;" />





从流程可以看出来，写redo log分成两步完成，这就是所谓的“两阶段提交”，是为了跟binlog保证一致。“两阶段提交”思想可用于保证两份数据写一致的场景。

>######1.为什么这样就可以保证两份log一致了？
>
>由于binlog和redo log是两个独立的逻辑，如果不采用“两阶段提交”，则有
>
>a.先写binlog，再写redo log，中间MySQL crash了，因为redo log这个事务还没提交，MySQL不会恢复这一条数据，但是在binlog中已经写了，所以会多出来一个事务。
>
>b.先写redo log，再写binlog，中间MySQL crash了，事务已经提交了，但是没有这条更新的binlog，所以在利用binlog恢复数据的时候就会丢失一次更新。
>
>
>
>######2.这个是表示写内存还是写磁盘文件？
>
>虽然具体实现上是先写内存，再通过一定策略flush到磁盘。具体策略后面再了解，这里暂时当做是写磁盘。
>
>两种日志flush到磁盘的策略可以分别通过下面两个参数控制
>
>redo log: innodb_flush_log_at_trx_commit = 1 有哪几种配置，每种配置分别代表什么意思？
>
>binlog: sync_binlog =1 问题同上
>
>###### 3.如果在binlog前MySQL down掉，怎么恢复？
>
>后续再看
>
>###### 4.如果在写binlog后（commit redo log之前）MySQL down掉，怎么恢复？
>
>后续再看
>
>###### 5.“两阶段提交”在平常业务开发中的应用？
>
>用redis做缓存，怎么保证和数据库中的数据一致？等解决了上面两个问题后，这种场景下就知道怎么设计方案了。
>
>[一致性问题](https://coolshell.cn/about)这篇文章讲得还不错，如果需要强一致性，就需要两阶段提交，但是这样会降低系统的性能。



